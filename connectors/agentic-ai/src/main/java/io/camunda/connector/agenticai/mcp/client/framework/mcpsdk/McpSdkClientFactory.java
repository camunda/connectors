/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a proprietary license.
 * See the License.txt file for more information. You may not use this file
 * except in compliance with the proprietary license.
 */
package io.camunda.connector.agenticai.mcp.client.framework.mcpsdk;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.camunda.connector.agenticai.mcp.client.McpClientFactory;
import io.camunda.connector.agenticai.mcp.client.configuration.McpClientConfigurationProperties;
import io.camunda.connector.agenticai.mcp.client.execution.McpClientDelegate;
import io.camunda.connector.agenticai.mcp.client.framework.bootstrap.McpClientHeadersSupplierFactory;
import io.camunda.connector.agenticai.mcp.client.framework.mcpsdk.rpc.McpSdkMcpClientDelegate;
import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.transport.HttpClientSseClientTransport;
import io.modelcontextprotocol.client.transport.HttpClientStreamableHttpTransport;
import io.modelcontextprotocol.client.transport.ServerParameters;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.json.McpJsonMapper;
import io.modelcontextprotocol.spec.McpClientTransport;
import io.modelcontextprotocol.spec.McpSchema;
import java.time.Duration;
import java.util.List;
import java.util.Optional;

public class McpSdkClientFactory implements McpClientFactory {

  private final ObjectMapper objectMapper;
  private final McpClientHeadersSupplierFactory headersSupplierFactory;

  public McpSdkClientFactory(
      ObjectMapper objectMapper, McpClientHeadersSupplierFactory headersSupplierFactory) {
    this.objectMapper = objectMapper;
    this.headersSupplierFactory = headersSupplierFactory;
  }

  @Override
  public McpClientDelegate createClient(
      String clientId, McpClientConfigurationProperties.McpClientConfiguration config) {
    var clientBuilder =
        McpClient.sync(createTransport(config))
            .clientInfo(
                new McpSchema.Implementation(
                    "Camunda MCP Connector - Client ID: %s".formatted(clientId), "1.0.0"))
            .capabilities(McpSchema.ClientCapabilities.builder().roots(false).build());

    Optional.ofNullable(config.initializationTimeout()).map(clientBuilder::initializationTimeout);
    Optional.ofNullable(config.toolExecutionTimeout()).map(clientBuilder::requestTimeout);

    return new McpSdkMcpClientDelegate(clientBuilder.build(), objectMapper);
  }

  private McpClientTransport createTransport(
      McpClientConfigurationProperties.McpClientConfiguration config) {
    return switch (config.transport()) {
      case McpClientConfigurationProperties.StdioMcpClientTransportConfiguration
              stdioMcpClientTransportConfiguration ->
          createStdioTransport(stdioMcpClientTransportConfiguration);
      case McpClientConfigurationProperties.StreamableHttpMcpClientTransportConfiguration
              streamableHttpMcpClientTransportConfiguration ->
          createStreamableHttpTransport(streamableHttpMcpClientTransportConfiguration);
      case McpClientConfigurationProperties.SseHttpMcpClientTransportConfiguration
              sseHttpMcpClientTransportConfiguration ->
          createSseTransport(sseHttpMcpClientTransportConfiguration);
    };
  }

  private StdioClientTransport createStdioTransport(
      McpClientConfigurationProperties.StdioMcpClientTransportConfiguration stdioConfig) {

    return new StdioClientTransport(
        ServerParameters.builder(stdioConfig.command()).args(stdioConfig.args()).build(),
        McpJsonMapper.createDefault());
  }

  private HttpClientStreamableHttpTransport createStreamableHttpTransport(
      McpClientConfigurationProperties.StreamableHttpMcpClientTransportConfiguration
          streamableHttpConfig) {
    var headerSuppliers = headersSupplierFactory.createHttpHeadersSupplier(streamableHttpConfig);

    return HttpClientStreamableHttpTransport.builder(streamableHttpConfig.url())
        .connectTimeout(timeout(streamableHttpConfig.timeout()))
        .supportedProtocolVersions(List.of("2025-11-25", "2025-06-18", "2025-03-26", "2024-11-05"))
        .customizeRequest(
            request -> {
              var headers = headerSuppliers.get();
              headers.forEach(request::header);
            })
        .build();
  }

  private HttpClientSseClientTransport createSseTransport(
      McpClientConfigurationProperties.SseHttpMcpClientTransportConfiguration sseConfig) {
    var headerSuppliers = headersSupplierFactory.createHttpHeadersSupplier(sseConfig);

    return HttpClientSseClientTransport.builder(sseConfig.url())
        .connectTimeout(timeout(sseConfig.timeout()))
        .customizeRequest(
            request -> {
              var headers = headerSuppliers.get();
              headers.forEach(request::header);
            })
        // todo proxy configuration
        .build();
  }

  private Duration timeout(Duration setTimeout) {
    return setTimeout != null ? setTimeout : Duration.ofSeconds(30);
  }
}
